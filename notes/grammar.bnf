
Program ::= ( StatementOrPreprocessor ";" ) *

StatementOrPreprocessor ::= Statement | Preprocessor

Preprocessor ::= "#" "include" Identifier | "#" "import" Identifier

StatementList ::= "{" ( Statement [ ";" ] ) * "}"

Statement ::= [ "export" ] VarDeclaration
  | [ "export" ] TypeDeclaration
  | [ "export" ] FnDeclaration
  | ExternFnDeclaration
  | Expression
  | ComptimeForLoop
  | ForLoop
  | Assignment

Expression ::= "(" Expression ")"
  | StatementList
  | ComptimeFnDeclaration
  | Comptime
  | Literal
  | Identifier
  | QualifiedName
  | QualifiedType
  | Expression
  | FunctionCall
  | MakeExpression
  | "undefined"
  | MetaTypeIdent
  | FnType
  | ComptimeIf
  | If
  | UnaryOp Expression
  | Lambda
  | "comptime" Expression
  // This is double-used - when specifying an array type (i.e. int[3]) AND accessing (i.e. foo[3])
  | ArrayAccess
  | Range

VarDeclaration ::= [ "comptime" ] "var" Identifier [ ":" Expression ] "=" Expression
  | [ "comptime" ] "mut" Identifier [ ":" Expression ] "=" Expression
  
FnDeclaration ::=
  "fn" Identifier [ TemplateParameterDeclList ] "=" FnSignature Expression

ExternFnDeclaration ::=
  "extern" "fn" Identifier "=" FnSignature

ComptimeFnDeclaration ::= "comptime" "fn" Identifier "=" FnSignature Expression
  | "comptime" "fn" Identifier ParameterDeclList "=" FnSignature Expression

FnSignature ::= ParameterDeclList [ "mut" ] [ "->" Expression ]

FnType ::= "fn" FnSignature

TypeDeclaration ::= type Identifier "=" TypeDefinition

TypeDefinition ::= Expression
  | Comptime
  | StructDefinition
  | EnumDefinition

EnumDefinition ::= "enum" "{" ( EnumField [ "," ] ) * "}"

EnumField ::= Identifier [ "(" Expression ")" ]

// comma only optional for last field
StructDefinition ::= "struct" "{" ( StructField [ "," ] ) * "}"

StructField ::= ["static"] MemberVarDecl | ["static"] FnDeclaration

// The literal should be an integer, since it's a bitfield
MemberVarDecl ::= Identifier ":" Expression [ "{" Literal "}" ] [ "=" Expression ]

Comptime ::= "comptime" StatementList

ParameterDeclList ::= "(" ( ParameterDecl [","] ) * ")"
TemplateParameterDeclList ::= "<" ( ParameterDecl [","] ) * ">"
ParameterDecl ::= Identifier ":" Expression | Expression
ParameterList ::= "(" ( Expression [","] ) * ")"
TemplateParameterList ::= "<" ( Expression [","] ) * ">"

// TODO Solve this, should be Expression :: Ident :: Ident ... but this is left
// recursive
QualifiedName ::= Expression
  | Expression "::" QualifiedName
  | Expression "." QualifiedName
  | Expression "." IntLit

QualifiedType ::= Expression "::" TemplateParameterList

MetaTypeIdent ::= "$" "type"
  | "$" "expr"

/* Actual code, rather than data definition */

MakeExpression ::= "make" Expression "{" ( Expression [","] ) * "}"
  // Initialise array
  | "make" Identifier "[" ( Expression [","] ) * "]"
  // Duplicate across array
  | "make" Identifier "[" Expression ";" Expression "]"

ComptimeForLoop ::= "comptime" ForLoop
ComptimeIf ::= "comptime" If

ForLoop ::= "for" Identifier "in" Expression Expression
If ::= "if" Expression StatementList Elif * [ Else ]
Elif ::= "elif" Expression StatementList
Else ::= "else" Expression StatementList

Lambda ::= "lambda" FnSignature Expression

BinaryExpression ::= Expression BinaryOp Expression

BinaryOp ::= Any op apart from "=", see separate Assignment nterm

Assignment ::= Expression "=" Expression

FunctionCall ::= Expression  ParameterList
ArrayAccess ::= Expression "[" Expression "]"

// Used as a slice or as range in for loops
Range ::= Expression ".." Expression