
Program ::= ( StatementOrPreprocessor ";" ) *

StatementOrPreprocessor ::= Statement | Preprocessor

Preprocessor ::= "#" "include" Identifier | "#" "import" Identifier

StatementList ::= "{" ( Statement [ ";" ] ) * "}"

Statement ::= [ "export" ] VarDeclaration
  | [ "export" ] TypeDeclaration
  | [ "export" ] FnDeclaration
  | ExternFnDeclaration
  | Expression
  | ComptimeForLoop
  | ForLoop

Expression ::= StatementList
  | ComptimeFnDeclaration
  | Comptime
  | Literal
  | Identifier
  | QualifiedName
  | Expression
  | FunctionCall
  | MakeExpression
  | EnumVariantExpression
  | "undefined"
  | MetaTypeIdent
  | FnType
  | ComptimeIf
  | If
  | UnaryOp Expression
  | Lambda

VarDeclaration ::= "var" Identifier [ ":" Expression ] "=" Expression
  
FnDeclaration ::=
  "fn" Identifier [ TemplateParameterDeclList ] "=" FnSignature Expression

ExternFnDeclaration ::=
  "extern" "fn" Identifier "=" FnSignature

ComptimeFnDeclaration ::= "comptime" "fn" Identifier "=" FnSignature Expression
  | "comptime" "fn" Identifier ParameterDeclList "=" FnSignature Expression

FnSignature ::= ParameterDeclList [ "mut" ] [ "->" Expression ]

FnType ::= "fn" FnSignature

TypeDeclaration ::= type Identifier "=" TypeDefinition

TypeDefinition ::= Expression
  | Comptime
  | StructDefinition
  | EnumDefinition

EnumDefinition ::= "enum" "{" ( EnumField [ "," ] ) * "}"

EnumField ::= Identifier [ "(" Expression ")" ]

// comma only optional for last field
StructDefinition ::= "struct" "{" ( StructField [ "," ] ) * "}"

StructField ::= ["static"] MemberVarDecl | ["static"] FnDeclaration

// The literal should be an integer, since it's a bitfield
MemberVarDecl ::= Identifier ":" Expression [ "{" Literal "}" ] [ "=" Expression ]

Comptime ::= "comptime" StatementList

ParameterDeclList ::= "(" ( ParameterDecl [","] ) * ")"
TemplateParameterDeclList ::= "<" ( ParameterDecl [","] ) * ">"
ParameterDecl ::= Identifier ":" Expression | Expression
ParameterList ::= "(" ( Expression [","] ) * ")"
TemplateParameterList ::= "<" ( Expression [","] ) * ">"

// TODO Solve this, should be Expression :: Ident :: Ident ... but this is left
// recursive
QualifiedName ::= Expression
  | Expression "::" QualifiedName
  | Expression "." QualifiedName
  | Expression "." IntLit

MetaTypeIdent ::= "$" "type"
  | "$" "expr"

/* Actual code, rather than data definition */

MakeExpression ::= "make" Identifier "{" ( Expression [","] ) * "}"
  | "make" Expression ParameterList

ComptimeForLoop ::= "comptime" ForLoop
ComptimeIf ::= "comptime" If

ForLoop ::= "for" Identifier "in" Expression Expression
If ::= "if" Expression Expression Elif * [ Else ]
Elif ::= "elif" Expression Expression
Else ::= "else" Expression Expression

Lambda ::= "lambda" FnSignature Expression

BinaryExpression ::= Expression BinaryOp Expression

FunctionCall ::= Expression [ "::" TemplateParameterList ] ParameterList